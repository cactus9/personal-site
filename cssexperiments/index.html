<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>CSS Experiments</title>
        <link rel="stylesheet" href="../styles/fonts.css">
        <link rel="stylesheet" href="../styles/article.css">
        <link rel="icon" type="image/x-icon" href="../images/favicon.svg">
        <style media="screen">
        :root {
            --code-color: #3C006C;
        }
            .code {
                background-color: var(--code-color);
                color:white;
                padding: 0.5em;
                overflow-x: scroll;
            }
            code {
                color: var(--code-color);
                font-weight: bold;
            }
            button {
                position: relative;
                border: 1px solid black;
                border-radius: 5em;
                background-color: white;
                padding-left: 1em;
                padding-right: 1em;
                padding-top: 0.5em;
                padding-bottom: 0.5em;
                font-size: 1em;
                transition: all 0.5s ease-in-out;
                left: 50%;
                transform: translate(-50%);
            }
            button:hover {
                animation-play-state: paused;
                filter: drop-shadow(0em 0em 0.5em lightblue);
                border-color: blue;
            }
            .pulsebutton {
                animation: pulse 0.75s alternate infinite;
            }
            @keyframes pulse {
                to {
                    color: blue;
                    border-color: blue;
                }
            }

            iframe, .frame {
                border:1px solid black;
                min-height: 20ch;
            }

            .frame {
                perspective: 800px;
                perspective-origin: top center;
                transform-style: preserve-3d;
                display: grid;
            }

            .box {
                position: absolute;
                width: 4em;
                height: 4em;
                background-color: #C071FFE0;
                padding: 0.5em;
                color:white;
                place-self: center;
                text-align: center;
            }
            .box1 {
                animation: move 2s infinite;
            }
            .box p {
                margin: 0px;
            }
            @keyframes move {
                50% {
                    transform: rotate(45deg);
                }
                100% {
                    transform: translate(2em, 3em) rotate(45deg);
                }
            }
            .pbox1, .pbox2, .pbox3 {
                animation: pslide 2s linear infinite alternate;
            }
            .pbox1 {
                transform: translateZ(-5em);
            }
            .pbox2 {
                filter: hue-rotate(120deg);
            }
            .pbox3 {
                filter: hue-rotate(240deg);
                transform: translateZ(5em);
            }
            @keyframes pslide {
                from {left: 10%;}
                to {left: calc(90% - 5em);}
            }
            .rotbox {
                animation: rotbox 2s linear infinite
            }
            @keyframes rotbox {
                to {transform: rotateY(360deg);}
            }
            .holder {
                height: 0px;
                width: 0px;
                place-self:center;
                display: grid;
                animation: rotholder 7s linear infinite;
            }
            @keyframes rotholder {
                to {transform: rotateZ(360deg) rotateY(360deg);}
            }
        </style>
    </head>
    <body>
        <a href="../" id="home-button"><img src="../images/favicon.svg" title="Home"><p>Home</p></a>
        <header>
            <h1>CSS is Kinda Wild</h1>
        </header>
        <article>

            <h2>Introduction</h2>
            <p><b>Cascading Style Sheets</b> (CSS) is a programming language developed in the mid-90s with the goal of styling web pages, currently maintained by the <a href="https://www.w3.org/Consortium/">World Wide Web Consortium's</a> <a href="https://www.w3.org/groups/wg/css">CSS Working Group</a>.<br><br>For the first decade or so of the language's existence its scope and mission-statement were fairly straightforward: web pages are made up of images, paragraphs, videos, etc. that need to be positioned and sized accordingly. In 2007 however, Apple's representatives in the Working Group put forward a <a href="https://lists.w3.org/Archives/Public/www-style/2008Mar/0313.html">wishlist</a> of features that the company wanted to see incoporated into the language. These included 3 incredibly powerful tools for creating design-complex pages (all of which incidentally are used on this site's homepage):</p>
            <ul>
                <li><b>2D and 3D transformations</b> - translations, rotations, skews performed in either 2 or 3 dimensions</li>
                <li><b>Animations and transitions</b> - event-triggered or "ambient" animations, e.g. the fill effect I use on links. Can include transformations, allowing for dynamic 3D effects</li>
                <li><b>Filter effects</b> - blurring and hue-shifting images, drop-shadows, etc.</li>
            </ul>
            <p>I only found out that 3D animations were possible in CSS about 6 months ago, and my initial reactions to this revelation were</p>
            <ol>
                <li>"Wow! That's really cool."</li>
                <li>"Wait, then what's the point of &ltcanvas&gt?"</li>
            </ol>
            <p>These features are neat and all, but this wasn't even new to the web when this was first proposed - it's that this used to be primarily handled by JavaScript libraries. Additionally, when I've shown people the demos I've made using pure CSS, their reaction always carries a feeling of "CSS? <i>Really?</i>" - a slight bafflement, a sense that putting this functionality in CSS is somehow unintuitive. Anyone familiar with the language will know that "intuitive" has never been an accurate descriptor for any aspect of CSS, but still. <br><br>The reason why these features are in the language is simple: Apple asked for them, and a lot of the group thought they were nifty. There was also some <a href="https://lists.w3.org/Archives/Public/www-style/2008Mar/0322.html">discussion</a> on CSS not wanting to become irrelevant as other technologies began to fulfill demands for presenting web content. As for why Apple specifically was the one to call for these, it's hard to tell. As an aside, I recommend reading one Apple representative's hilariously shady and unprofessional <a href="https://lists.w3.org/Archives/Public/www-style/2008Mar/0321.html">response</a> to a Microsoft employee questioning if these features were really appropriate. It brought me joy.<br><br>Appropriate or not, in this article I want to explore not only what you can do with these features, but also have a closer look at what the designs of their implementations ended up being.</p>
            <h3>CSS crash course</h3>
            <p>As some of you reading this may not have worked with CSS before or perhaps need a refresher, here's a brief run-down of how CSS works. On a basic level, CSS documents are a list of rules that take the following structure:</p>
            <pre class="code">
selector {
    property: value;
    other-property: other-value;
    ...
}</pre>
            <p>Where <code>selector</code> is some string specifying which parts of a web page to apply that styling rule to. For a concrete example of these in action, the following is the code for a page with a single paragraph colored red (CSS being put in the &ltstyle&gt section):</p>
            <pre class="code">
&lthtml&gt
    &lthead&gt
        &ltstyle&gt
            p {
                color:red;
            }
        &lt/style&gt
    &lt/head&gt
    &ltbody&gt
        &ltp&gtThis is a paragraph.&lt/p&gt
    &lt/body&gt
&lt/html&gt</pre>
            <div class="frame" >
                <p style="color:red">This is a paragraph.</p>
            </div>

            <h2>Animations and transitions</h2>
            <p>Often when styling web pages, you want to be able to change the presentation of content depending on how the user interacts with it. For example, when the user hovers over a button you might want it to glow slightly, or perhaps when they click on an image you might want it to smoothly move to the center of the screen and expand. <i>Transitions</i> in CSS allow us to define exactly those kinds of changes in styling.</p>
            <pre class="code">
button {
    border: 1px solid black;
    transition: all 0.5s ease-in-out;
}
button:hover {
    filter: drop-shadow(0em 0em 0.5em lightblue);
    border-color: blue;
}</pre>
            <button type="button">Hover to glow!</button>
            <p><code>em</code> here is a unit of length based on font size.<br><br>In order to create the above, I have defined two rules - one is applied to the button in its "default" mode, the other applies to the button only when it is hovered over by the user. When the button is hovered over, the first rule defines the start of the transition and the second the end goal. With the <code>transition</code> keyword, I define which properties are included in my transition ("all" for convenience), how long I want the whole transition to take, and a <i>timing function</i> that helps me control the feel of the final result. Compare the above with changing the timing function to <code>linear</code>:</p>
            <button type="button" style="transition-timing-function: linear">Linear timing</button>
            <p>The difference is subtle, but the eased function has a bounce to it that is missing in the linear one; the linear function feels sluggish in comparison.<br><br>Transitions define how content moves from a default styling to some other styling due to some interaction with the user - an explicit trigger. An <i>animation</i> is very similar, except it is not triggered by something the user does - it just happens on its own. Because we aren't looking at triggers like hovering or clicking to define endpoints for the animation, we'll instead write keyframes for it. For example, let's take the glowing button from earlier and make it pulse eerily in the background while the user is not hovering over it.</p>
<pre class="code">
.pulsebutton {
    animation: pulse 0.75s alternate infinite;
}
@keyframes pulse {
    to {
        color: blue;
        border-color: blue;
    }
}
</pre>
            <button type="button" class="pulsebutton">pulse pulse pulse</button>
            <p>In the above rule for the <code>pulsebutton</code> class, we are saying that we will play the <code>pulse</code> animation back-and-forth forever, with each forward pass and each backward pass taking 0.75 seconds. The <code>to</code> keyword signals the rules for the end state of the animation, but I could also have used percentages if I wanted some rules to only apply halfway through.<br><br> In terms of the designs of these features, I actually really like them. The examples I've shown have been simple, but I think it's not too hard to see how you could build these up to create a truly dynamic and impressive design for a website. It's far from perfect, of course. Having to remember what order keywords go in for the <code>animation</code> rule is always a pain, I'm disappointed that you can't define transitions through the powerful keyframes syntax, and trying to transition already-animated features of an element just doesn't work right. Overall though, solid 8/10.</p>

            <h2>2D and 3D transformations</h2>
            <p>This is where things start to get wild.<br><br> So 2D transformations are pretty straightforward - you have an object, and you want to move it around a bit. To see this in action, let's set up a box that we can move around. First, let's twist it 45 degrees to the right, then move it. </p>
<pre class="code">
#box {
    animation: move 2s infinite;
}
@keyframes move {
    50% {
        transform: rotate(45deg);
    }
    100% {
        transform: translate(2em, 3em) rotate(45deg);
    }
}
</pre>
            <div class="frame" style="height: 15ch">
                <div class="box box1"></div>
            </div>
            <p>Notice that we have to specify the rotation in both keyframes - at each point you have to describe the entire value any property that you change. If we didn't, then the box would untwist as it moved down.<br><br>However, this is HTML - we can put things in these boxes. Consider the same animation, but this time we'll put some text in the box. Notice that it's still treated as text that you can highlight, copy, edit, etc.</p>
            <div class="frame" style="height: 15ch">
                <div class="box box1"><p>Try selecting me!</p></div>
            </div>
            <p>2D is pretty cool and all, but if it's not good enough for Apple then it's not good enough for us! Let's see how we can take it further.</p>
            <h3>3D transformations</h3>
            <p>In all fairness, there's not as much jank afoot here in the design as there could have been. With that being said, 3D in CSS takes some getting used to.<br><br>Defining distance in the x-axis and y-axis is pretty easy on a web page - you just use the dimensions of the computer screen. For 3D however, we'll need to introduce the z-axis, which will correspond to how far away elements appear to the user. Now we don't actually know how far away the user is from their screen, but chances are it'll be about arm's length, so we'll set the <code>perspective</code> value to be around that distance. <code>perspective</code> essentially positions the viewer themselves in 3D space, specifically by giving the z value of their position. Elements that have been moved forwards on the z-axis appear closer, and those moved back appear more distant. As for specifying the x and y values of the viewer's position, that's where <code>perspective-origin</code> comes into play. Why not just do all of them in one keyword? Because.<br><br>To illustrate the role of <code>perspective</code>, let's make the same 3D animation 3 times, each having its own value. </p>
<pre class="code">
container {
    perspective: XXX;
    perspective-origin: top center;
}

.pbox1, .pbox2, .pbox3 {
    position: absolute;
    animation: pslide 2s linear infinite alternate;
}
.pbox1 {
    transform: translateZ(-5em);
}
.pbox3 {
    transform: translateZ(5em);
}
@keyframes pslide {
    from {
        left: 10%; /* We'll adjust the left margin of each element to make it move */
    }
    to {
        left: calc(90% - 5em);
    }
}
</pre>
            <figure>
                <div class="frame" style="perspective: 400px">
                    <div class="box pbox1"></div>
                    <div class="box pbox2"></div>
                    <div class="box pbox3"></div>
                </div>
                <figcaption><code>perspective: 400px</code> </figcaption>
            </figure>
            <figure>
                <div class="frame" style="perspective: 800px">
                    <div class="box pbox1"></div>
                    <div class="box pbox2"></div>
                    <div class="box pbox3"></div>
                </div>
                <figcaption><code>perspective: 800px</code> </figcaption>
            </figure>
            <figure>
                <div class="frame" style="perspective: 1200px">
                    <div class="box pbox1"></div>
                    <div class="box pbox2"></div>
                    <div class="box pbox3"></div>
                </div>
                <figcaption><code>perspective: 1200px</code> </figcaption>
            </figure>
            <p>Without having to do any math of our own, we can create this really slick parallax effect using pure CSS. I think that's cool. And just as we had translations and rotations in 2D, we have them in 3D as well.</p>
<pre class="code">
box {
    animation: rotate 2s linear infinite
}
@keyframes rotate {
    to {
        transform: rotateY(360deg);
    }
}
</pre>
            <div class="frame">
                <div class="box rotbox"></div>
            </div>
            <p>But these are still HTML elements, so we can put whatever we want in them:</p>
            <div class="frame">
                <div class="box rotbox"><p>Try selecting me!</p>
                </div>
            </div>
            <p>Now I can't speak for everyone, but that text on a rotating box is fairly annoying to read. While it is certainly intriguing to consider the potential of what you can accomplish using purely CSS, we can't forget that the point of this language is to make web content more accessible and pleasing to consume. In a practical sense the use-cases for making the text spin are extremely limited, which again calls into question whether all this is really necessary for CSS.<br><br>Ignoring practicality for now, let's explore the possibilites of what we can do. We know that we can make flat rectangles and call them boxes, but what about actual boxes? A cube is made up of 6 squares, so if we just draw 6 boxes and adjust accordingly, we should get something good.</p>
<pre class="code">
box1 {
    transform: translateZ(2.5em);
}
box2 {
    transform: translateZ(-2.5em);
}
box3 {
    transform: translateY(2.5em) rotateX(90deg);
}
...
</pre>
            <div class="frame" style="perspective: 400px">
                <div class="box" style="transform: translateZ(2.5em)"></div>
                <div class="box" style="filter: hue-rotate(40deg); transform: translateZ(-2.5em)"></div>
                <div class="box" style="filter: hue-rotate(80deg); transform: translateY(2.5em) rotateX(90deg)"></div>
                <div class="box" style="filter: hue-rotate(120deg); transform: translateY(-2.5em) rotateX(-90deg)"></div>
                <div class="box" style="filter: hue-rotate(160deg); transform: translateX(2.5em) rotateY(90deg)"></div>
                <div class="box" style="filter: hue-rotate(200deg); transform: translateX(-2.5em) rotateY(-90deg)"></div>
            </div>
            <p>Well, it took a lot of positioning and little bit of work to get it right, but you can indeed make actual boxes! It's kinda hard to see things properly without an animation, so let's make it rotate. Now we could animate each element individually, but that would require writing a seperate set of keyframes and rules for each of the 6 faces. A better option would be to place the entire set of faces into some kind of holder element and animate that holder instead - much less code, and a lot easier to adjust the look of. Let's try it:</p>
<pre class="code">
holder {
    animation: rotate 7s linear infinite;
}
@keyframes rotate {
    to {
        transform: rotateZ(360deg) rotateY(360deg);
    }
}
</pre>
            <div class="frame" style="perspective: 400px">
                <div class="holder">
                    <div class="box" style="transform: translateZ(2.5em)"></div>
                    <div class="box" style="filter: hue-rotate(40deg); transform: translateZ(-2.5em)"></div>
                    <div class="box" style="filter: hue-rotate(80deg); transform: translateY(2.5em) rotateX(90deg)"></div>
                    <div class="box" style="filter: hue-rotate(120deg); transform: translateY(-2.5em) rotateX(-90deg)"></div>
                    <div class="box" style="filter: hue-rotate(160deg); transform: translateX(2.5em) rotateY(90deg)"></div>
                    <div class="box" style="filter: hue-rotate(200deg); transform: translateX(-2.5em) rotateY(-90deg)"></div>
                </div>
            </div>
            <p>Wait, where did all the boxes go? You can only see one of them, but they're all still part of the file, and I didn't delete any of their transformations. Unfortunately, this is where jank enters stage left. If you try to rotate any HTML element in 3D, the default behaviour in CSS is to flatten everything within that element - the 3D effects applied to the faces contained in our holder are effectively nullified. They aren't entirely gone, but they've been squished back into 2 dimensions which in our case ruins the effect. There is a way to rectify this - if we specify <code>transform-style: preserve-3d</code> in our holder element, then the effect applied to the faces within are not removed. Take a look now: </p>
<pre class="code">
holder {
    animation: rotate 7s linear infinite;
    transform-style: preserve-3d;
}
</pre>
            <div class="frame" style="perspective: 400px">
                <div class="holder" style="transform-style: preserve-3d">
                    <div class="box" style="transform: translateZ(2.5em)"></div>
                    <div class="box" style="filter: hue-rotate(40deg); transform: translateZ(-2.5em)"></div>
                    <div class="box" style="filter: hue-rotate(80deg); transform: translateY(2.5em) rotateX(90deg)"></div>
                    <div class="box" style="filter: hue-rotate(120deg); transform: translateY(-2.5em) rotateX(-90deg)"></div>
                    <div class="box" style="filter: hue-rotate(160deg); transform: translateX(2.5em) rotateY(90deg)"></div>
                    <div class="box" style="filter: hue-rotate(200deg); transform: translateX(-2.5em) rotateY(-90deg)"></div>
                </div>
            </div>
            <p>From this, we now know we can faithfully model any shape that can be broken down into boxes. What about curves? Well, as far as I've seen it is not possible to model any kind of curved surface in CSS. The best we can do is approximate them with some number of flat segments. For example, let's try to model a smooth ring:</p>
        </article>
        <footer></footer>

    </body>
</html>
